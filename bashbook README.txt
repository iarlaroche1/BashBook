Description
So in server.sh in gedit I wrote a while true loop to infinitely loop while the script is running. "enter request is printed to the screen. The input is read in as request, then using set -- it splits the input string into separate arguments $1, $2 etc. The first argument $1 is then assigned to variable cmd whixh represents command (post, add etc). The shift command is used to move positional parameters to the left by one position which removes the first argument $1. Now $1 will refer to the second argument , so $2 goes to $1 , $3 goes to $2 etc. This way, the command specifier is stored in cd and not handled by the rest of the script. cmd variable can be used separately for checks. Shift moves the arguments down so that $@ (all remaining arguments) contains the parameters we need to process. This allows the script to separate the command itself from the arguments that follow it for smooth handling.

Then, case statement is used to compare $cmd to "help", "create", "add", "post", "display". I will explain each case below. Note in each case, the arguments starting from after the initial $1 are processed because the shift operation I described earlier. If the request matches the case, their corresponding scripts are run.

Help: I added the help request as a way to show the user what command formats are available in the script. It displays available commands and their purpose.

Create: creates a user with the given id argument in create.sh with the id as an argument.. If -z (string is empty) display error message and continue without running create.sh. otherwise run create .sh I opted to use the continue instead of exit because it was annoying me every time my script ended every time I made an error in my input. If no issue with the arguments, then a directory called "$id" is made, so if $id="iarla" then a directory called iarla will be made. Then an empty file inside of this directory is made so in this case for example iarla/wall.txt. This is empty at first but later it will store messages posted on the user's wall.
Another empty file is created in this directory called friends.txt where the user's friends list will be stored. When all of this is done, the script alerts the user with a success message. If any fail, create.sh exits with error code.

add: adds a friend to the user with the given id using add_friend.sh where argument 1 is the id and argument 2 is the frind to be added. If the request format is not ok, display error message. If the id doesn't exist (wasn't made in create.sh) then alert user. If friend doesn't exist alert user. These are checked using ! -d "$" which check for the existence of these files. Next, grep -q "^$friend$" "$id/friends.txt" is used. grep searches for patterns in files. -q makes it not output anything and just set exit code. exit with 0 if pattern found, 1 if not. ^$friend$ is the pattern searched for, so ^is the start of a line, $friend is the variable that is storing the name of the friend and $ is the end of the line. So, the argument is searched for within the friends file. If found, exit. else, move on and add friend. this is done by appending

post: this one was tricky as it gave me a lot o trouble with handling arguments. The text wasnt displaying properly, and it didnt make sense to list countless arguments. So initially the first argument is assigned to sender variable ( person posting message), second argument is assigned to receiver variable(person receiving messge), then shift 2 is applied which moves the positional parameters to the left by 2 , which removes the first two arguments so that the leftover ones can be read as the message without losing any words after spaces. message variable is set to be "$*", meaning all remaining arguments are stored as a string. This allows for sentences with punctuation to be stored rather than just words.
These arguments are then checked to see if they exist , if they do then run the posy_message.sh script with these arguments. if not continue. In the post_message script it is checked that the snder , receiver exist, and if the the sender is a friend of the receiver (using similar greg check as in add) . If any of these are the case, the script exits with an error message indicating why. If not, The message is appended to the receiver's wall.txt file. The user is alerted that their message has been posted.

display: first arguments stored as id. If id provided checked using -z "$id" . If not exist, continue to next iteration of loop. If exists, call ./display_wall.sh which displays the users wall. In this scriot the argument id is taken as argument. It checks if user file exists using -d. If it exists, contents of this users wall.txt are displayed using cat.


If no command matches, bad requesr is shown to user. End of case esac.
